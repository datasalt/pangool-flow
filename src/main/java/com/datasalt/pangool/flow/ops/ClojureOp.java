package com.datasalt.pangool.flow.ops;

import java.io.IOException;

import clojure.lang.AFn;
import clojure.lang.PersistentList;
import clojure.lang.PersistentVector;

import com.datasalt.pangool.io.Fields;
import com.datasalt.pangool.io.ITuple;
import com.datasalt.pangool.io.Schema;

/**
 * Op to be used by the Clojure facade to Pangool-flow 
 * (Work-in-progress)
 */
@SuppressWarnings("serial")
public class ClojureOp<K> extends TupleOp<K> {

	private AFn function;
	
	public ClojureOp(AFn function) {
		this.function = function;
	}
	
	public ClojureOp(AFn function, String schema) {
		super(new Schema("autogenerated", Fields.parse(schema)));
		this.function = function;		
	}
	
	public ClojureOp(AFn function, Schema schema) {
		super(schema);
		this.function = function;
	}

//	private Object[] cachedTupleArray;
	
	@Override
  public void process(K input, ReturnCallback<ITuple> callback) throws IOException, InterruptedException {
		Object feed = input;

		// Invoke Clojure function 
		Object res = function.invoke(feed, callback);
		// Let the user return something besides using the callback - (for expressiveness)
		// (If more than one thing needs to be returned, then the callback needs to be used)
		if(res != null) {
			// we allow Clojure Lists or Vectors as representations of Tuples
			if(res instanceof PersistentList) {
				for(int i = 0; i < tuple.getSchema().getFields().size(); i++) {
					tuple.set(i, ((PersistentList)res).get(i));
				}
				callback.onReturn(tuple);
			} else if(res instanceof PersistentVector) {
				for(int i = 0; i < tuple.getSchema().getFields().size(); i++) {
					tuple.set(i, ((PersistentVector)res).get(i));
				}
				callback.onReturn(tuple);
			} else if(res instanceof ITuple) {
				callback.onReturn((ITuple)res);
			} else {
				throw new RuntimeException("Unknown return type after applying clojure function (" + function + "): " + res.getClass());
			}
		}
	}
}
